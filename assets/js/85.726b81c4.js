(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{193:function(e,a,v){"use strict";v.r(a);var _=v(0),t=Object(_.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,v=e._self._c||a;return v("div",{staticClass:"content"},[v("h1",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[e._v("#")]),e._v(" 总结")]),v("p",[e._v("正如本书所展示的，webpack是一个多功能的工具。为了更容易地回顾内容和技术，请浏览下面的列表。")]),v("h2",{attrs:{id:"一般列表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一般列表","aria-hidden":"true"}},[e._v("#")]),e._v(" 一般列表")]),v("ul",[v("li",[v("strong",[e._v("Source maps")]),e._v(" 允许你在开发的过程中在浏览器中调试代码。如果你捕获了输出，它们还可以在生产使用期间提供更高质量的堆栈跟踪。"),v("em",[e._v("Source maps")]),e._v(" 这章深入讲解了这个主题。")]),v("li",[e._v("为了保持你的构建快速，考虑到优化。"),v("em",[e._v("Performance")]),e._v(" 这章介绍了实现这个目的的各种策略。")]),v("li",[e._v("为了保持你的配置的可维护性，请考虑合成它。由于webpack配置是JavaScript代码，所以可以通过多种方式进行安排。"),v("em",[e._v("Composing Configuration")]),e._v(" 这章讲解了这个主题。")]),v("li",[e._v("webpack的引入依赖包的方式可自定义。"),v("em",[e._v("Consuming Packages")]),e._v(" 这章讲了了与此相关的技术。")]),v("li",[e._v("有时你不得不扩展webpack。"),v("em",[e._v("loader的扩展")]),e._v(" 和 "),v("em",[e._v("plugins的扩展")]),e._v(" 这两章介绍了如何实现。你还可以在webpack的配置定义之上工作，并实现你自己的抽象，使之适合你的目的。")])]),v("h2",{attrs:{id:"开发列表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#开发列表","aria-hidden":"true"}},[e._v("#")]),e._v(" 开发列表")]),v("ul",[v("li",[e._v("要在开发过程中充分利用webpack，请使用 "),v("em",[e._v("webpack-dev-server")]),e._v(" (WDS)。你还可以找到可以在开发期间附加到节点服务器的中间件。"),v("em",[e._v("浏览器自动刷新")]),e._v(" 这章详细地讲解了WDS。")]),v("li",[e._v("Webpack实现 "),v("strong",[e._v("热模块替换")]),e._v(" (HMR)。它允许你在应用程序运行时替换模块，而无需强制浏览器刷新。"),v("em",[e._v("热交换")]),e._v(" 附录详细介绍了这个主题。")])]),v("h2",{attrs:{id:"生产列表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#生产列表","aria-hidden":"true"}},[e._v("#")]),e._v(" 生产列表")]),v("h3",{attrs:{id:"样式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#样式","aria-hidden":"true"}},[e._v("#")]),e._v(" 样式")]),v("ul",[v("li",[e._v("Webpack 默认内联样式到JavaScript中。为了避免这种情况，可以使用"),v("code",[e._v("MiniCssExtractPlugin")]),e._v(" 或等效解决方案将CSS分离到"),v("code",[e._v("*.css")]),e._v(" 类型的文件中。"),v("em",[e._v("分离CSS")]),e._v("这章介绍了如何实现。")]),v("li",[e._v("为了减少编写的CSS数量，请考虑 "),v("strong",[e._v("Autoprefixing")]),e._v(" 。"),v("em",[e._v("Autoprefixing")]),e._v(" 这章讲解了如何实现。")]),v("li",[e._v("基于静态分析可以清除未使用的CSS样式。"),v("em",[e._v("Eliminating Unused CSS")]),e._v(" 这章讲解了这种技术的基本思想。")])]),v("h3",{attrs:{id:"静态资源"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#静态资源","aria-hidden":"true"}},[e._v("#")]),e._v(" 静态资源")]),v("ul",[v("li",[e._v("通过webpack加载图片时，优化它们，这样用户下载的东西就少了。"),v("em",[e._v("Loading Images")]),e._v(" 这章展示了如何做到这一点。")]),v("li",[e._v("根据你需要支持的浏览器，只加载你需要的字体。"),v("em",[e._v("Loading Fonts")]),e._v(" 这章讲解了这个主题。")]),v("li",[e._v("缩小你的源文件可以确保浏览器减少客户端下载的负载。"),v("em",[e._v("Minifying")]),e._v(" 这章展示了如何做到这一点。")])]),v("h3",{attrs:{id:"缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存","aria-hidden":"true"}},[e._v("#")]),e._v(" 缓存")]),v("ul",[v("li",[e._v("要从客户端缓存中获益，请将vendor相关信息从应用程序中分离出来，单独打包。这样做的话，在理想的情况下，客户端下载的东西就少了。"),v("em",[e._v("Bundle split")]),e._v(" 这章讲解了这个主题。"),v("em",[e._v("添加哈希到文件名")]),e._v(" 这章展示了如何在此基础上实现缓存失效。")]),v("li",[e._v("使用webpack的 "),v("strong",[e._v("代码分割")]),e._v(" 功能来按需加载代码。这种技术是手动触发的，你不需要立即加载所有代码，而是逻辑触发(如：单击用户界面元素)之后，将其推入。"),v("em",[e._v("代码分割")]),e._v(" 这章详细介绍了这种技术。"),v("em",[e._v("动态加载")]),e._v(" 这章展示了如何处理更高级的场景。")]),v("li",[e._v("将hash添加到文件名中，如："),v("em",[e._v("将散列添加到文件名中")]),e._v(" 这一章节中所述，这样可以从缓存中获益，并分离一个manifest以进一步改进解决方案，如："),v("em",[e._v("分离清单")]),e._v(" 章节所述。")])]),v("h3",{attrs:{id:"优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优化","aria-hidden":"true"}},[e._v("#")]),e._v(" 优化")]),v("ul",[v("li",[e._v("使用ES2015模块定义来做 "),v("strong",[e._v("tree shaking")]),e._v("。它允许webpack通过静态分析来清除未使用的代码路径。关于它的技术思想，请参阅 "),v("em",[e._v("Tree Shaking")]),e._v(" 这一章。")]),v("li",[e._v("设置特定的应用程序的环境变量，在生产模式下进行编译。你可以用这种方法实现特性标签。请参阅 "),v("em",[e._v("Environment Variables")]),e._v(" 这章来阐述该技术。")]),v("li",[e._v("分析构建的统计数据，以了解需要改进的内容。"),v("em",[e._v("Build Analysis")]),e._v(" 这一章展示了如何用多个可用的工具来做这件事。")]),v("li",[e._v("将一部分计算推给了 Web Workers。"),v("em",[e._v("Web Workers")]),e._v(" 这一章介绍了如何实现这一点。")])]),v("h3",{attrs:{id:"输出"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#输出","aria-hidden":"true"}},[e._v("#")]),e._v(" 输出")]),v("ul",[v("li",[e._v("清理并将关于构建的信息附加到结果中。"),v("em",[e._v("Tidying Up")]),e._v(" 这一章展示了如何做到这一点。")])]),v("h2",{attrs:{id:"总结-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结-2","aria-hidden":"true"}},[e._v("#")]),e._v(" 总结")]),v("p",[e._v("Webpack允许你使用很多不同的技术来拼接你的构建。它支持本书 "),v("em",[e._v("output")]),e._v(" 部分中讲解的多种输出格式。与名字无关，它不只是用于Web。虽然大多数人用它做Web开发，但它能做的远不止于此。")])])}],!1,null,null,null);t.options.__file="13_conclusion.md";a.default=t.exports}}]);